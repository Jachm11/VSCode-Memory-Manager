A \href{http://en.wikipedia.org/wiki/Persistent_data_structure}{\texttt{ fully persistent}} \href{http://en.wikipedia.org/wiki/Red\%E2\%80\%93black_tree}{\texttt{ red-\/black tree}} written 100\% in Java\+Script. Works both in node.\+js and in the browser via \href{http://browserify.org/}{\texttt{ browserify}}.

Functional (or fully presistent) data structures allow for non-\/destructive updates. So if you insert an element into the tree, it returns a new tree with the inserted element rather than destructively updating the existing tree in place. Doing this requires using extra memory, and if one were naive it could cost as much as reallocating the entire tree. Instead, this data structure saves some memory by recycling references to previously allocated subtrees. This requires using only O(log(n)) additional memory per update instead of a full O(n) copy.

Some advantages of this is that it is possible to apply insertions and removals to the tree while still iterating over previous versions of the tree. Functional and persistent data structures can also be useful in many geometric algorithms like point location within triangulations or ray queries, and can be used to analyze the history of executing various algorithms. This added power though comes at a cost, since it is generally a bit slower to use a functional data structure than an imperative version. However, if your application needs this behavior then you may consider using this module.

\doxysection*{Install}

\begin{DoxyVerb}npm install functional-red-black-tree
\end{DoxyVerb}


\doxysection*{Example}

Here is an example of some basic usage\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//Load the library}
\DoxyCodeLine{var createTree = require("functional-\/red-\/black-\/tree")}
\DoxyCodeLine{}
\DoxyCodeLine{//Create a tree}
\DoxyCodeLine{var t1 = createTree()}
\DoxyCodeLine{}
\DoxyCodeLine{//Insert some items into the tree}
\DoxyCodeLine{var t2 = t1.insert(1, "foo")}
\DoxyCodeLine{var t3 = t2.insert(2, "bar")}
\DoxyCodeLine{}
\DoxyCodeLine{//Remove something}
\DoxyCodeLine{var t4 = t3.remove(1)}
\end{DoxyCode}


\doxysection*{A\+PI}


\begin{DoxyCode}{0}
\DoxyCodeLine{var createTree = require("functional-\/red-\/black-\/tree")}
\end{DoxyCode}


\doxysubsection*{Overview}


\begin{DoxyItemize}
\item \href{\#tree-methods}{\texttt{ Tree methods}}
\begin{DoxyItemize}
\item \href{\#var-tree-=-createtreecompare}{\texttt{ {\ttfamily var tree = create\+Tree(\mbox{[}compare\mbox{]})}}}
\item \href{\#treekeys}{\texttt{ {\ttfamily tree.\+keys}}}
\item \href{\#treevalues}{\texttt{ {\ttfamily tree.\+values}}}
\item \href{\#treelength}{\texttt{ {\ttfamily tree.\+length}}}
\item \href{\#treegetkey}{\texttt{ {\ttfamily tree.\+get(key)}}}
\item \href{\#treeinsertkey-value}{\texttt{ {\ttfamily tree.\+insert(key, value)}}}
\item \href{\#treeremovekey}{\texttt{ {\ttfamily tree.\+remove(key)}}}
\item \href{\#treefindkey}{\texttt{ {\ttfamily tree.\+find(key)}}}
\item \href{\#treegekey}{\texttt{ {\ttfamily tree.\+ge(key)}}}
\item \href{\#treegtkey}{\texttt{ {\ttfamily tree.\+gt(key)}}}
\item \href{\#treeltkey}{\texttt{ {\ttfamily tree.\+lt(key)}}}
\item \href{\#treelekey}{\texttt{ {\ttfamily tree.\+le(key)}}}
\item \href{\#treeatposition}{\texttt{ {\ttfamily tree.\+at(position)}}}
\item \href{\#treebegin}{\texttt{ {\ttfamily tree.\+begin}}}
\item \href{\#treeend}{\texttt{ {\ttfamily tree.\+end}}}
\item \href{\#treeforEachvisitorkeyvalue-lo-hi}{\texttt{ {\ttfamily tree.\+for\+Each(visitor(key,value)\mbox{[}, lo\mbox{[}, hi\mbox{]}\mbox{]})}}}
\item \href{\#treeroot}{\texttt{ {\ttfamily tree.\+root}}}
\end{DoxyItemize}
\item \href{\#node-properties}{\texttt{ Node properties}}
\begin{DoxyItemize}
\item \href{\#nodekey}{\texttt{ {\ttfamily node.\+key}}}
\item \href{\#nodevalue}{\texttt{ {\ttfamily node.\+value}}}
\item \href{\#nodeleft}{\texttt{ {\ttfamily node.\+left}}}
\item \href{\#noderight}{\texttt{ {\ttfamily node.\+right}}}
\end{DoxyItemize}
\item \href{\#iterator-methods}{\texttt{ Iterator methods}}
\begin{DoxyItemize}
\item \href{\#iterkey}{\texttt{ {\ttfamily iter.\+key}}}
\item \href{\#itervalue}{\texttt{ {\ttfamily iter.\+value}}}
\item \href{\#iternode}{\texttt{ {\ttfamily iter.\+node}}}
\item \href{\#itertree}{\texttt{ {\ttfamily iter.\+tree}}}
\item \href{\#iterindex}{\texttt{ {\ttfamily iter.\+index}}}
\item \href{\#itervalid}{\texttt{ {\ttfamily iter.\+valid}}}
\item \href{\#iterclone}{\texttt{ {\ttfamily iter.\+clone()}}}
\item \href{\#iterremove}{\texttt{ {\ttfamily iter.\+remove()}}}
\item \href{\#iterupdatevalue}{\texttt{ {\ttfamily iter.\+update(value)}}}
\item \href{\#iternext}{\texttt{ {\ttfamily iter.\+next()}}}
\item \href{\#iterprev}{\texttt{ {\ttfamily iter.\+prev()}}}
\item \href{\#iterhasnext}{\texttt{ {\ttfamily iter.\+has\+Next}}}
\item \href{\#iterhasprev}{\texttt{ {\ttfamily iter.\+has\+Prev}}}
\end{DoxyItemize}
\end{DoxyItemize}

\doxysubsection*{Tree methods}

\doxysubsubsection*{{\ttfamily var tree = create\+Tree(\mbox{[}compare\mbox{]})}}

Creates an empty functional tree


\begin{DoxyItemize}
\item {\ttfamily compare} is an optional comparison function, same semantics as array.\+sort()
\end{DoxyItemize}

{\bfseries{Returns}} An empty tree ordered by {\ttfamily compare}

\doxysubsubsection*{{\ttfamily tree.\+keys}}

A sorted array of all the keys in the tree

\doxysubsubsection*{{\ttfamily tree.\+values}}

An array array of all the values in the tree

\doxysubsubsection*{{\ttfamily tree.\+length}}

The number of items in the tree

\doxysubsubsection*{{\ttfamily tree.\+get(key)}}

Retrieves the value associated to the given key


\begin{DoxyItemize}
\item {\ttfamily key} is the key of the item to look up
\end{DoxyItemize}

{\bfseries{Returns}} The value of the first node associated to {\ttfamily key}

\doxysubsubsection*{{\ttfamily tree.\+insert(key, value)}}

Creates a new tree with the new pair inserted.


\begin{DoxyItemize}
\item {\ttfamily key} is the key of the item to insert
\item {\ttfamily value} is the value of the item to insert
\end{DoxyItemize}

{\bfseries{Returns}} A new tree with {\ttfamily key} and {\ttfamily value} inserted

\doxysubsubsection*{{\ttfamily tree.\+remove(key)}}

Removes the first item with {\ttfamily key} in the tree


\begin{DoxyItemize}
\item {\ttfamily key} is the key of the item to remove
\end{DoxyItemize}

{\bfseries{Returns}} A new tree with the given item removed if it exists

\doxysubsubsection*{{\ttfamily tree.\+find(key)}}

Returns an iterator pointing to the first item in the tree with {\ttfamily key}, otherwise {\ttfamily null}.

\doxysubsubsection*{{\ttfamily tree.\+ge(key)}}

Find the first item in the tree whose key is {\ttfamily $>$= key}


\begin{DoxyItemize}
\item {\ttfamily key} is the key to search for
\end{DoxyItemize}

{\bfseries{Returns}} An iterator at the given element.

\doxysubsubsection*{{\ttfamily tree.\+gt(key)}}

Finds the first item in the tree whose key is {\ttfamily $>$ key}


\begin{DoxyItemize}
\item {\ttfamily key} is the key to search for
\end{DoxyItemize}

{\bfseries{Returns}} An iterator at the given element

\doxysubsubsection*{{\ttfamily tree.\+lt(key)}}

Finds the last item in the tree whose key is {\ttfamily $<$ key}


\begin{DoxyItemize}
\item {\ttfamily key} is the key to search for
\end{DoxyItemize}

{\bfseries{Returns}} An iterator at the given element

\doxysubsubsection*{{\ttfamily tree.\+le(key)}}

Finds the last item in the tree whose key is {\ttfamily $<$= key}


\begin{DoxyItemize}
\item {\ttfamily key} is the key to search for
\end{DoxyItemize}

{\bfseries{Returns}} An iterator at the given element

\doxysubsubsection*{{\ttfamily tree.\+at(position)}}

Finds an iterator starting at the given element


\begin{DoxyItemize}
\item {\ttfamily position} is the index at which the iterator gets created
\end{DoxyItemize}

{\bfseries{Returns}} An iterator starting at position

\doxysubsubsection*{{\ttfamily tree.\+begin}}

An iterator pointing to the first element in the tree

\doxysubsubsection*{{\ttfamily tree.\+end}}

An iterator pointing to the last element in the tree

\doxysubsubsection*{{\ttfamily tree.\+for\+Each(visitor(key,value)\mbox{[}, lo\mbox{[}, hi\mbox{]}\mbox{]})}}

Walks a visitor function over the nodes of the tree in order.


\begin{DoxyItemize}
\item {\ttfamily visitor(key,value)} is a callback that gets executed on each node. If a truthy value is returned from the visitor, then iteration is stopped.
\item {\ttfamily lo} is an optional start of the range to visit (inclusive)
\item {\ttfamily hi} is an optional end of the range to visit (non-\/inclusive)
\end{DoxyItemize}

{\bfseries{Returns}} The last value returned by the callback

\doxysubsubsection*{{\ttfamily tree.\+root}}

Returns the root node of the tree

\doxysubsection*{\mbox{\hyperlink{class_node}{Node}} properties}

Each node of the tree has the following properties\+:

\doxysubsubsection*{{\ttfamily node.\+key}}

The key associated to the node

\doxysubsubsection*{{\ttfamily node.\+value}}

The value associated to the node

\doxysubsubsection*{{\ttfamily node.\+left}}

The left subtree of the node

\doxysubsubsection*{{\ttfamily node.\+right}}

The right subtree of the node

\doxysubsection*{Iterator methods}

\doxysubsubsection*{{\ttfamily iter.\+key}}

The key of the item referenced by the iterator

\doxysubsubsection*{{\ttfamily iter.\+value}}

The value of the item referenced by the iterator

\doxysubsubsection*{{\ttfamily iter.\+node}}

The value of the node at the iterator\textquotesingle{}s current position. {\ttfamily null} is iterator is node valid.

\doxysubsubsection*{{\ttfamily iter.\+tree}}

The tree associated to the iterator

\doxysubsubsection*{{\ttfamily iter.\+index}}

Returns the position of this iterator in the sequence.

\doxysubsubsection*{{\ttfamily iter.\+valid}}

Checks if the iterator is valid

\doxysubsubsection*{{\ttfamily iter.\+clone()}}

Makes a copy of the iterator

\doxysubsubsection*{{\ttfamily iter.\+remove()}}

Removes the item at the position of the iterator

{\bfseries{Returns}} A new binary search tree with {\ttfamily iter}\textquotesingle{}s item removed

\doxysubsubsection*{{\ttfamily iter.\+update(value)}}

Updates the value of the node in the tree at this iterator

{\bfseries{Returns}} A new binary search tree with the corresponding node updated

\doxysubsubsection*{{\ttfamily iter.\+next()}}

Advances the iterator to the next position

\doxysubsubsection*{{\ttfamily iter.\+prev()}}

Moves the iterator backward one element

\doxysubsubsection*{{\ttfamily iter.\+has\+Next}}

If true, then the iterator is not at the end of the sequence

\doxysubsubsection*{{\ttfamily iter.\+has\+Prev}}

If true, then the iterator is not at the beginning of the sequence

\doxysection*{Credits}

(c) 2013 Mikola Lysenko. M\+IT License 